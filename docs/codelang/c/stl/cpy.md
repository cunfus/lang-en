# 标准库 strcpy

看了 [在 C 中，如何正确拷贝字符串](https://liujiacai.net/blog/2023/12/02/strcpy/) 一文，没想到这些地方还有容易忽视的问题，特来验证一下。


## `strcpy`

```c
void test_strcpy()
{
    char src[5];
    char dst[10];

    memset(&src, 'a', 5);
    memset(&dst, '1', 10);

    strcpy(dst, src);
}


(gdb) x/32xb src
0x7fffffffd439: 0x61    0x61    0x61    0x61    0x61    0x31    0x31    0x31
0x7fffffffd441: 0x31    0x31    0x31    0x31    0x31    0x31    0x31    0x00
0x7fffffffd449: 0x67    0x13    0x3d    0xa2    0x2a    0x7d    0x9d    0x60
0x7fffffffd451: 0xd4    0xff    0xff    0xff    0x7f    0x00    0x00    0xd4
(gdb) n
(gdb) x/32xb src
0x7fffffffd439: 0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffd441: 0x61    0x61    0x31    0x31    0x31    0x31    0x31    0x31
0x7fffffffd449: 0x31    0x31    0x31    0x31    0x00    0x7d    0x9d    0x60
0x7fffffffd451: 0xd4    0xff    0xff    0xff    0x7f    0x00    0x00    0xd4
(gdb) p src
$1 = "aaaaa"
(gdb) p dst
$2 = "aaaaa11111"
(gdb) p &dst
$3 = (char (*)[10]) 0x7fffffffd43e
```
从内存上看，src 紧接着 dst，

可以看到因为 src 不是以`NUL`结尾，它的范围被扩大到了第一个 0x00，然后`strcpy`操作从 dst 的起始地址开始覆盖，dst 实际位置之后的内存被修改了，如果 dst 后续有一个数组大小等同于 src，且内容是`？`，那么它将全部修改成 dst 后续的内容，俗称踩内存。

```c
void test_strcpy()
{
    char src[5];
    char dst[10];
    char ques[5];
    
    memset(&src, 'a', 5);
    memset(&dst, '1', 10);
    memset(&ques, '?', 5);
    
    strcpy(dst, src);
    
}

(gdb) x/32xb src
0x7fffffffd434: 0x61    0x61    0x61    0x61    0x61    0x3f    0x3f    0x3f
0x7fffffffd43c: 0x3f    0x3f    0x31    0x31    0x31    0x31    0x31    0x31
0x7fffffffd444: 0x31    0x31    0x31    0x31    0x00    0x46    0x2c    0xa5
0x7fffffffd44c: 0x37    0x71    0x2c    0x1c    0x60    0xd4    0xff    0xff
(gdb) n
(gdb) x/32xb src
0x7fffffffd434: 0x61    0x61    0x61    0x61    0x61    0x3f    0x3f    0x3f
0x7fffffffd43c: 0x3f    0x3f    0x61    0x61    0x61    0x61    0x61    0x3f
0x7fffffffd444: 0x3f    0x3f    0x3f    0x3f    0x31    0x31    0x31    0x31
0x7fffffffd44c: 0x31    0x31    0x31    0x31    0x31    0x31    0x00    0xff

```
实际情况更有趣，编译器将 ques 的空间放在了 src 和 dst 之后，导致 dst 最后变成了 `aaaaa?????`，且 dst 之后的空间仍踩了内存。

dst 的长度不够这种情况，根据变量内存分布，必然发生覆盖多余的字节。

## `strncpy`

看样子要限制复制的长度了，但对于`'\0'`，strncpy 也不能处理完美。

比如将 src 的 `NUL` 拷贝给了 dst，导致 dst 从中截断。


## `memcpy`

既然一定要知道 src 的长度，就如文章中说的那样，直接用 `memcpy`。这样更直观，让人意识到这是在操纵内存字节，从而考虑 `NUL` 的情况。